<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Gannon Barnett</title><link href="https://gbarnett.github.io/" rel="alternate"></link><link href="https://gbarnett.github.io/feeds/all.atom.xml" rel="self"></link><id>https://gbarnett.github.io/</id><updated>2020-08-06T10:00:00-04:00</updated><entry><title>SitReady, My First App</title><link href="https://gbarnett.github.io/first-app.html" rel="alternate"></link><published>2020-08-06T10:00:00-04:00</published><updated>2020-08-06T10:00:00-04:00</updated><author><name>Gannon Barnett</name></author><id>tag:gbarnett.github.io,2020-08-06:/first-app.html</id><summary type="html">&lt;p&gt;The first app I built, SitReady, was a rowing timing application. Some background on rowing and the problem- rowing races can range from 2k-6k meters in length depending on the season and course. To time rowing races, there are two timing stations- one at the start and finish. Boats are …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The first app I built, SitReady, was a rowing timing application. Some background on rowing and the problem- rowing races can range from 2k-6k meters in length depending on the season and course. To time rowing races, there are two timing stations- one at the start and finish. Boats are marked with bow numbers to serve as an identifier, and each boat’s total time is the difference between the time marked for it at the two stations. At a regatta an expensive timing company will be hired to keep track of this process; commonly the company HereNow. During practice this method requires a coach to serve as a timing station, and times are calculated at the end by manually comparing marked times. This manual process can be time consuming, and rowers must wait for the coach from the start to meet the coach from the finish to compare times, which can often take several minutes (too long for  an excited crew). That is the crux of the problem SitReady is solving: live results from crew races can’t be achieved in day-to-day operations.&lt;/p&gt;
&lt;p&gt;I coded SitReady in Swift for iOS and used GCP/Firebase for backend services. I was really excited about it and was able to get a version published in about a month. Once published, I showed it to my high school coaches, who used it a few times. After I fixed a few bugs, I looked into how to get SitReady out to more coaches. It was winter at the time, teams were off the water and there were no upcoming regattas. I looked to erg competitions that would have the same audience, and landed on buying an advertising square on  C.R.A.S.H.-B.’s site for $300/year. I never really was able to convince coaches to use the platform, and ran out of steam developing it to really implement the last few features coaches wanted.&lt;/p&gt;
&lt;p&gt;SitReady was my first dive into the business of app development and it was a blast. I was able to distribute a product and iterate on it based on user feedback. In hindsight, I would’ve spent more time making sure the product worked and was always trustworthy, because I learned my target audience really cared about accuracy. Also I wouldn’t have spent the money on advertising online and would’ve instead cold-called coaches to introduce them to the product. In the end I think it didn’t expand much because 1) the product has defects (looks unprofessional, occasional bug) and 2) I didn’t have the means to reach the target audience. Regardless I still think that the idea has potential to break into the rowing world, and to this day I still get the occasional email from a coach asking about certain features. Definitely on my todo list if I have time to improve and release this app for both iOS and Android.&lt;/p&gt;
&lt;p&gt;More on my other two published apps, Rough Riderz and The Watt Farm App, to come soon!&lt;/p&gt;
</content><category term="mobile"></category></entry><entry><title>My NoSQL User Profile Design</title><link href="https://gbarnett.github.io/nosql-user-profile.html" rel="alternate"></link><published>2020-08-01T10:00:00-04:00</published><updated>2020-08-01T10:00:00-04:00</updated><author><name>Gannon Barnett</name></author><id>tag:gbarnett.github.io,2020-08-01:/nosql-user-profile.html</id><summary type="html">&lt;p&gt;In this article I'll review a database design I created for handling user profiles while
prioritizing security and scalability.
Below are the main features I'll review:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;public profile (name, bio, photo …)&lt;/li&gt;
&lt;li&gt;private/secure data (sensitive financial or personal data)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I picked these features because in my original design I found …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this article I'll review a database design I created for handling user profiles while
prioritizing security and scalability.
Below are the main features I'll review:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;public profile (name, bio, photo …)&lt;/li&gt;
&lt;li&gt;private/secure data (sensitive financial or personal data)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I picked these features because in my original design I found some subtle optimizations
that you might miss during your design phase (like I did). I'll be going over database design,
and stay out of code/ specific tools. But if you're wondering, I used Google Cloud Products.
Specifically I used Firestore (GCP NoSQL database), Firebase Auth and Firebase Storage (large file storage).&lt;/p&gt;
&lt;div class="section" id="public-user-profile"&gt;
&lt;h2&gt;Public User Profile&lt;/h2&gt;
&lt;p&gt;Storing a public user profile is fairly straightforward; all attributes of the profile can just be attributes of the user document.&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://gbarnett.github.io/images/messaging_1.png" style="width: 894px; height: 249px;" /&gt;
&lt;p&gt;Now let’s add user profile pictures. I integrated Firebase Storage for a large-file storage service. When linking objects from a storage service, it's important to store the file path, and not a URL. This is important for two reasons; first, the access tokens may change and the URL may expire; second, this abstraction allows for easy integration of requesting different sizes of the same image to allow for application scalability and flexibility. With some iPhone images being almost 3mb and 4k pixels, being able to request smaller image sizes can save a substantial amount of download time and storage costs.&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://gbarnett.github.io/images/messaging_2.png" style="width: 200px; height: 286px;" /&gt;
&lt;p&gt;With this design, we can resize images by adding a suffix to the original photo id
indicating the file’s scale, and then dynamically generate a filepath.
I could then request the URL for a given filepath and serve it. To implement this
I added a listener to the photos path of my storage bucket which would resize images
when they were added.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="secure-user-information"&gt;
&lt;h2&gt;Secure User Information&lt;/h2&gt;
&lt;p&gt;Next, let’s allow for adding secure data. In a NoSQL database, data is loaded each document
at a time so you can't restrict access on specific key/value pairs of a document. Regardless
of what your application retains from document, the entire document is transferred over the network
and cached in the browser, allowing a malicious party to access secure information!&lt;/p&gt;
&lt;p&gt;We want different security rules for different parts of the database. To achieve
this we can put different classes of data in different collections.&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://gbarnett.github.io/images/messaging_3.png" style="width: 896px; height: 494px;" /&gt;
&lt;p&gt;Now that public and private information are separated, we can selectively expose
only the public information. The private information can still be utilized in the server
context, but it will never be insecurely transferred to the client. Wahoo!&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://gbarnett.github.io/images/messaging_4.png" style="width: 580px; height: 198px;" /&gt;
&lt;p&gt;These rules allow secure information to only exist in trusted services. Effectively,
these rules state:
- the user’s document is public
- the user’s ‘secure’ subcollection is never allowed to be read, written, or updated, but data can be accessed by server functions&lt;/p&gt;
&lt;/div&gt;
</content><category term="systems"></category></entry></feed>
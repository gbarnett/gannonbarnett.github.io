<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Gannon Barnett - systems</title><link href="https://gbarnett.github.io/" rel="alternate"></link><link href="https://gbarnett.github.io/feeds/systems.atom.xml" rel="self"></link><id>https://gbarnett.github.io/</id><updated>2020-08-01T10:00:00-04:00</updated><entry><title>My NoSQL User Profile Design</title><link href="https://gbarnett.github.io/nosql-user-profile.html" rel="alternate"></link><published>2020-08-01T10:00:00-04:00</published><updated>2020-08-01T10:00:00-04:00</updated><author><name>Gannon Barnett</name></author><id>tag:gbarnett.github.io,2020-08-01:/nosql-user-profile.html</id><summary type="html">&lt;p&gt;In this article I'll review a database design I created for handling user profiles while
prioritizing security and scalability.
Below are the main features I'll review:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;public profile (name, bio, photo …)&lt;/li&gt;
&lt;li&gt;private/secure data (sensitive financial or personal data)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I picked these features because in my original design I found …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this article I'll review a database design I created for handling user profiles while
prioritizing security and scalability.
Below are the main features I'll review:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;public profile (name, bio, photo …)&lt;/li&gt;
&lt;li&gt;private/secure data (sensitive financial or personal data)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I picked these features because in my original design I found some subtle optimizations
that you might miss during your design phase (like I did). I'll be going over database design,
and stay out of code/ specific tools. But if you're wondering, I used Google Cloud Products.
Specifically I used Firestore (GCP NoSQL database), Firebase Auth and Firebase Storage (large file storage).&lt;/p&gt;
&lt;div class="section" id="public-user-profile"&gt;
&lt;h2&gt;Public User Profile&lt;/h2&gt;
&lt;p&gt;Storing a public user profile is fairly straightforward; all attributes of the profile can just be attributes of the user document.&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://gbarnett.github.io/images/messaging_1.png" style="width: 894px; height: 249px;" /&gt;
&lt;p&gt;Now let’s add user profile pictures. I integrated Firebase Storage for a large-file storage service. When linking objects from a storage service, it's important to store the file path, and not a URL. This is important for two reasons; first, the access tokens may change and the URL may expire; second, this abstraction allows for easy integration of requesting different sizes of the same image to allow for application scalability and flexibility. With some iPhone images being almost 3mb and 4k pixels, being able to request smaller image sizes can save a substantial amount of download time and storage costs.&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://gbarnett.github.io/images/messaging_2.png" style="width: 200px; height: 286px;" /&gt;
&lt;p&gt;With this design, we can resize images by adding a suffix to the original photo id
indicating the file’s scale, and then dynamically generate a filepath.
I could then request the URL for a given filepath and serve it. To implement this
I added a listener to the photos path of my storage bucket which would resize images
when they were added.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="secure-user-information"&gt;
&lt;h2&gt;Secure User Information&lt;/h2&gt;
&lt;p&gt;Next, let’s allow for adding secure data. In a NoSQL database, data is loaded each document
at a time so you can't restrict access on specific key/value pairs of a document. Regardless
of what your application retains from document, the entire document is transferred over the network
and cached in the browser, allowing a malicious party to access secure information!&lt;/p&gt;
&lt;p&gt;We want different security rules for different parts of the database. To achieve
this we can put different classes of data in different collections.&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://gbarnett.github.io/images/messaging_3.png" style="width: 896px; height: 494px;" /&gt;
&lt;p&gt;Now that public and private information are separated, we can selectively expose
only the public information. The private information can still be utilized in the server
context, but it will never be insecurely transferred to the client. Wahoo!&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://gbarnett.github.io/images/messaging_4.png" style="width: 580px; height: 198px;" /&gt;
&lt;p&gt;These rules allow secure information to only exist in trusted services. Effectively,
these rules state:
- the user’s document is public
- the user’s ‘secure’ subcollection is never allowed to be read, written, or updated, but data can be accessed by server functions&lt;/p&gt;
&lt;/div&gt;
</content><category term="systems"></category></entry></feed>